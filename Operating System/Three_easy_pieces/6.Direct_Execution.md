## 제한적 직접 실행 원리

CPU 시간을 나누어 써서 가상화를 구현할 수 있다고 했다. 이때 해결해야 하는 문제는 2가지 있다. 

1. 성능 저하 : 시스템에 과중한 오버헤드를 주지 않으면서 가상화를 구현해야 한다.
2. 제어 문제 : CPU에 대한 통제를 유지하면서 프로세스를 효율적으로 실행시켜야 한다. 

### 1. 기본 원리 : 제한적 직접 실행

- 제한적 직접 실행(Limited Direct Execution)
  - 직접 실행 = 프로그램을 CPU 상에서 그냥 직접 실행 
  - 직접 실행은 몇가지 문제가 있다. 프로그램이 위험한 일을 하지 않는다는 것을 어떻게 보장할 것인지와, CPU를 가상화하는데 필요한 시분할을 어떻게 구현할 수 있는지의 문제이다. 

### 2. 문제점1: 제한된 연산

하드웨어는 2가지 실행 모드를 제공한다 - **사용자 모드**, **커널 모드**. 사용자 모드에서 응용 프로그램은 하드웨어 자원에 대한 접근이 제한되어 있다. 커널 모드에서는 컴퓨터에 대한 모든 접근 권한을 가진다. 사용자에서 커널 모드로 전환하기 위한 trap 명령어와 사용자 모드로 되돌아가기 위한 return-from-trap 명령어가 있다. 

사용자 프로세스가 디스크 읽기 등 특권 명령어를 수행할 수 있게 하기 위해 **시스템 콜**을 제공한다.  

시스템 콜을 실행하기 위해 프로그램은 **trap** 특수 명령어를 실행해야 한다. 이 명령어는 커널 안으로 분기하는 동시에 특권 수준을 커널 모드로 상향 조정한다. 커널 모드로 진입하면 운영체제는 모든 명령어를 실행할 수 있고 이를 통하여 프로세스가 요청한 작업을 처리할 수 있다. 완료되면 운영체제는 **return-from-trap** 특수 명령어을 호출한다. 예상하는 것처럼 이 명령어는 특권 수준을 사용자 모드로 다시 하향 조정하면서 호출한 사용자 프로그램으로 리턴한다.

하드웨어는 trap 명령어를 수행할 때 호출한 프로세스의 필요한 레지스터를 저장해야 한다. 운영체제가 return-from-trap 실행 시 사용자 프로세스를 다시 리턴해야 하기 때문이다. x86에서는 PC, 플래그 등을 **커널 스택(kernel stack)** 에 저장한다. 

커널은 부팅 시에 **트랩 테이블(trap table)** 을 만들고, 이를 이용해 시스템을 통제한다. 인터럽트가 일어났을 때, 운영체제는 특정 명령어를 이용하여 하드웨어에게 **트랩 핸들러(trap handler)** 의 위치를 알려준다. 

<img width="559" alt="image" src="https://github.com/ddoddii/OS-CA-Study/assets/95014836/7f4c815e-708a-461b-b51a-1a3e9199d4a0">

### 3. 문제점2: 프로세스 간 전환

프로세스 간 전환에서 핵심은 운영체제가 CPU를 어떻게 다시 획득하는지이다. 

#### 협조 방식 : 시스템 콜 기다리기 

이 방식은 운영체제가 프로세스들이 합리적으로 행동할 것이라고 신뢰한다. 너무 오랫동안 실행할 가능성이 있는 프로세스는 주기적으로 CPU를 포기할 것이라고 가정한다. 운영체제에게 CPU 를 넘겨주는 것은 `yield()` 를 호출해서 할 수 있다. 이 시스템 콜은 운영체제에게 제어를 넘겨 운영체제가 다른 프로세스를 실행할 수 있게 한다. 


프로그램이 비정상적인 행위를 하면 운영체제에 제어가 넘어간다. 예를 들어, 0으로 나누는 연산을 하거나 접근할 수 없는 메모리에 접근하면 운영체제로의 **트랩**이 일어난다. 그러면 운영체제는 다시 CPU를 획득하여 해당 행위를 하는 프로세스를 종료할 수 있다.

협조 방식의 스케줄링 시스템에서 운영체제는 **시스템 콜이 호출되기를 기다리거나 불법적인 연산이 일어나기를 기다려서** CPU의 제어권을 다시 획득한다.

#### 비협조 방식 : 운영체제게 전권을 행사

프로세스가 비협조적인 상황에서도 CPU의 제어를 획득하는 방법은 무엇일까? 그것은 **타이머 인터럽트(timer interrupt)** 를 이용하는 방법이다. 인터럽트가 발생하면 현재 실행 중인 프로세스는 중단되고 운영체제의 **인터럽트 핸들러(interrupt handler)** 가 실행된다. 이때 운영체제는 CPU제어권을 다시 얻게 된다. 

#### 문맥의 저장과 복원

운영체제가 제어권을 다시 획득하면, **스케쥴러(scheduler)** 가 현재 실행 중인 프로세스를 계속 실행할지 아니면 다른 프로세스로 전환할 것인지 결정한다. 다른 프로세스로 전환하면, 운영체제는 **문맥 교환(context switch)** 코드를 실행한다. 

<img width="471" alt="image" src="https://github.com/ddoddii/OS-CA-Study/assets/95014836/621b1618-c034-48e9-99bb-0e0a37112c72">

이 과정이 실행되는 동안 **두 번의 레지스터의 저장/복원**이 일어난다는 것에 주의하자.
첫 번째는 타이머 인터럽트가 발생했을 때 일어난다. 이 경우 실행 중인 프로세스의 사용자 레지스터가 하드웨어에 의해 암묵적으로 저장되고 저장 장소로 해당 프로세스의 커널 스택이 사용된다. 두 번째는 운영체제가 A에서 B로 전환하기로 결정했을 때 일어 난다. 이 경우 커널 레지스터는 운영체제에 의하여 해당 프로세스의 프로세스 구조체에 저장된다. 이것은 운영체제가 A가 아닌 B로부터 커널로 트랩된 것처럼 만든다.

